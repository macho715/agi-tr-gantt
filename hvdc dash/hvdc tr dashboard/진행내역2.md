option_c.json과 dashboard-data.ts 확인 후, 발견된 이슈들을 반영해 개선안을 정리합니다.


[3 tools called]


점검 결과를 반영해 개선안을 정리했습니다. 우선순위별로 제시합니다.

---

# 점검 결과 반영 개선안

## 1. SSOT 타입 개선 (`lib/ssot/schedule.ts`)

요약행/일수 규칙/ID 요구사항을 명시합니다.

```typescript
/**
 * SSOT (Single Source of Truth) - Schedule Types
 * 
 * 개선사항 반영:
 * - activity_id null 처리 (요약행/그룹)
 * - 소수점 duration 규칙 명문화
 * - 순수 함수 규약 (불변성)
 * - UTC 날짜 연산
 * 
 * @see .cursor/rules/040-gantt-deadline.mdc
 * @see .cursor/rules/050-directory-map.mdc
 */

// ============================================================================
// 1. 기본 Enum 타입
// ============================================================================

export type DependencyType = "FS" | "SS" | "FF" | "SF"
export type AnchorType = "LOADOUT" | "SAIL_AWAY" | "BERTHING" | "LOADIN" | "TURNING" | "JACKDOWN"
export type TRUnitId = "TR-1" | "TR-2" | "TR-3" | "TR-4" | "TR-5" | "TR-6" | "TR-7"
export type ActivityStatus = "planned" | "in_progress" | "blocked" | "done"

// ============================================================================
// 2. 요약행/그룹 처리 규칙
// ============================================================================

/**
 * 활동 타입 (재계산 대상 구분)
 * - LEAF: 실제 작업 (activity_id 존재, 재계산 대상)
 * - SUMMARY: 요약/그룹 (activity_id null, 자식의 min/max로 rollup)
 */
export type ActivityNodeType = "LEAF" | "SUMMARY"

/**
 * 활동 ID 정규화 규칙
 * 
 * 1. LEAF 활동: activity_id 필수 (null 불가)
 * 2. SUMMARY 활동: activity_id = null, 합성 ID 생성 규칙:
 *    - 형식: `SUMMARY_${level1}_${level2 || "ROOT"}`
 *    - 예: "SUMMARY_MOBILIZATION_SPMT", "SUMMARY_OPERATIONAL"
 * 
 * 재계산 시:
 * - LEAF만 의존성 그래프에 포함
 * - SUMMARY는 자식들의 min(planned_start) ~ max(planned_finish)로 자동 계산
 */
export function normalizeActivityId(
  activity: Pick<ScheduleActivity, "activity_id" | "level1" | "level2">
): string {
  if (activity.activity_id !== null) {
    return activity.activity_id
  }
  // SUMMARY 합성 ID
  const level2Part = activity.level2 || "ROOT"
  return `SUMMARY_${activity.level1}_${level2Part}`
}

// ============================================================================
// 3. Duration 처리 규칙
// ============================================================================

/**
 * Duration 계산 규칙
 * 
 * 소수점 duration 처리 (option_c.json 기준):
 * - 0.2, 0.3, 0.5, 0.7: 반일/시간 단위 작업
 * - 1.5, 5.5: 일 단위 + 반일
 * 
 * 규칙:
 * - 저장: 원본 duration 유지 (소수점 포함)
 * - 날짜 계산: Math.ceil(duration) 사용 (올림)
 *   - 예: 0.5일 → 1일, 1.5일 → 2일
 * 
 * 이유:
 * - 계획된 시작일과 완료일은 일 단위로만 관리
 * - 반일 작업도 최소 1일로 취급 (운영 안전성)
 */
export function calculateFinishDate(startDate: string, duration: number): string {
  // UTC 기반 날짜 연산 (타임존/DST 영향 제거)
  const start = parseUTCDate(startDate)
  const days = Math.ceil(duration) // 올림 규칙
  return addUTCDays(start, days - 1).toISOString().split("T")[0]
}

// ============================================================================
// 4. UTC 날짜 연산 유틸
// ============================================================================

/**
 * UTC 기반 날짜 파싱 (YYYY-MM-DD → UTC Date)
 * DST/로컬 타임존 영향 없이 순수 일수 계산
 */
export function parseUTCDate(dateStr: string): Date {
  const [year, month, day] = dateStr.split("-").map(Number)
  return new Date(Date.UTC(year, month - 1, day))
}

/**
 * UTC 기반 날짜 덧셈 (일 단위)
 */
export function addUTCDays(date: Date, days: number): Date {
  const result = new Date(date)
  result.setUTCDate(result.getUTCDate() + days)
  return result
}

/**
 * UTC 기반 날짜 차이 계산 (일 단위)
 */
export function diffUTCDays(date1: string, date2: string): number {
  const d1 = parseUTCDate(date1)
  const d2 = parseUTCDate(date2)
  return Math.floor((d2.getTime() - d1.getTime()) / (1000 * 60 * 60 * 24))
}

// ============================================================================
// 5. 의존성 및 제약 조건
// ============================================================================

export interface ScheduleDependency {
  predecessorId: string
  type: DependencyType
  lagDays: number
}

export interface ScheduleConstraint {
  type: "START_NO_EARLIER_THAN" | "FINISH_NO_LATER_THAN" | "MUST_START_ON" | "MUST_FINISH_ON"
  date: string
  reason?: string
}

export interface ScheduleCalendar {
  weekendsOff?: boolean
  blackoutDates?: string[]
}

// ============================================================================
// 6. 스케줄 활동 (개선된 구조)
// ============================================================================

/**
 * 스케줄 활동
 * 
 * ID 규칙:
 * - activity_id: null이면 SUMMARY, 존재하면 LEAF
 * - 재계산 시 normalizeActivityId()로 안정적 ID 보장
 * 
 * Duration 규칙:
 * - 소수점 허용 (0.5, 1.5 등)
 * - 날짜 계산 시 Math.ceil() 적용
 */
export interface ScheduleActivity {
  // 기존 필드 (option_c.json 구조)
  activity_id: string | null
  activity_name: string
  level1: string
  level2: string | null
  duration: number  // 소수점 허용 (0.5, 1.5 등)
  planned_start: string
  planned_finish: string

  // 확장 필드
  tr_unit_id?: TRUnitId
  anchor_type?: AnchorType
  depends_on?: ScheduleDependency[]
  is_locked?: boolean
  constraint?: ScheduleConstraint
  calendar?: ScheduleCalendar
  resource_tags?: string[]
  voyage_id?: string
  milestone_id?: string
  status?: ActivityStatus
  
  // 내부 플래그 (계산 시 사용, 저장하지 않음)
  _is_summary?: boolean  // 요약행 여부 (activity_id === null)
}

// ============================================================================
// 7. 재계산 결과 (충돌 타입 추가)
// ============================================================================

export interface DateChange {
  activity_id: string
  old_start: string
  new_start: string
  old_finish: string
  new_finish: string
  delta_days: number
}

export interface ScheduleConflict {
  type: "RESOURCE" | "CONSTRAINT" | "LOCK_VIOLATION" | "DEPENDENCY_CYCLE"
  activity_id: string
  message: string
  severity: "warn" | "error"
  related_activity_ids?: string[]
}

export interface ImpactReport {
  affected_count: number
  affected_ids: string[]
  changes: DateChange[]
  conflicts: ScheduleConflict[]
}

export interface ReflowResult {
  activities: ScheduleActivity[]
  impact_report: ImpactReport
}

// ============================================================================
// 8. 재계산 옵션 (개선)
// ============================================================================

/**
 * 재계산 옵션
 * 
 * 개선사항:
 * - checkResourceConflicts: respectConstraints에서 분리
 * - detectCycles: 사이클 탐지 활성화
 */
export interface ReflowOptions {
  /** 오프셋 유지 모드 (방식 1: Template Offset Reflow) */
  preserveOffset?: boolean
  /** Lock 작업 존중 */
  respectLocks?: boolean
  /** 제약 조건 존중 */
  respectConstraints?: boolean
  /** 캘린더 제약 존중 */
  respectCalendar?: boolean
  /** 자원 충돌 검사 (별도 플래그) */
  checkResourceConflicts?: boolean
  /** 의존성 사이클 탐지 */
  detectCycles?: boolean
}

// ============================================================================
// 9. 상수 및 기본값
// ============================================================================

export const DEFAULT_TR_CHAIN_RULE: ScheduleDependency = {
  predecessorId: "",
  type: "FS",
  lagDays: 0,
}

export const DEFAULT_ANCHOR_TYPE: AnchorType = "LOADOUT"

export const DEFAULT_REFLOW_OPTIONS: ReflowOptions = {
  preserveOffset: false,
  respectLocks: true,
  respectConstraints: true,
  respectCalendar: false,
  checkResourceConflicts: true,
  detectCycles: true,  // 기본 활성화
}
```

---

## 2. 순수 함수 개선 (`lib/utils/schedule-reflow.ts` 핵심 부분)

불변성, 사이클 탐지, UTC 날짜 연산 적용.

```typescript
/**
 * 의존성 그래프 기반 스케줄 재계산 (순수 함수)
 * 
 * 개선사항:
 * - 불변성 보장 (깊은 복사)
 * - 사이클 탐지
 * - UTC 날짜 연산
 * - Lock/Constraint 제대로 처리
 */
export function reflowSchedule(
  activities: ScheduleActivity[],
  changedActivityId: string,
  newStartDate: string,
  options: ReflowOptions = DEFAULT_REFLOW_OPTIONS
): ReflowResult {
  // 1. 깊은 복사 (불변성 보장)
  const reflowed = activities.map(a => ({
    ...a,
    depends_on: a.depends_on ? [...a.depends_on] : undefined,
    resource_tags: a.resource_tags ? [...a.resource_tags] : undefined,
  }))
  
  // 2. LEAF 활동만 필터링 (SUMMARY 제외)
  const leafActivities = reflowed.filter(a => a.activity_id !== null)
  const leafIds = new Set(leafActivities.map(a => normalizeActivityId(a)))
  
  // 3. 의존성 그래프 빌드 (LEAF만)
  const graph = buildDependencyGraph(leafActivities)
  
  // 4. 사이클 탐지
  if (options.detectCycles !== false) {
    const cycles = detectDependencyCycles(graph, leafIds)
    if (cycles.length > 0) {
      return {
        activities: reflowed,
        impact_report: {
          affected_count: 0,
          affected_ids: [],
          changes: [],
          conflicts: cycles.map(cycle => ({
            type: "DEPENDENCY_CYCLE",
            activity_id: cycle[0],
            message: `Circular dependency detected: ${cycle.join(" → ")}`,
            severity: "error",
            related_activity_ids: cycle,
          })),
        },
      }
    }
  }
  
  // 5. 변경된 활동 검증
  const normalizedId = leafIds.has(changedActivityId)
    ? changedActivityId
    : Array.from(leafIds).find(id => normalizeActivityId({ activity_id: id, level1: "", level2: null }) === changedActivityId)
  
  if (!normalizedId) {
    throw new Error(`Activity ${changedActivityId} not found or is SUMMARY`)
  }
  
  const changed = leafActivities.find(a => normalizeActivityId(a) === normalizedId)
  if (!changed) {
    throw new Error(`Activity ${normalizedId} not found`)
  }
  
  // 6. Lock 검증
  if (options.respectLocks && changed.is_locked) {
    return {
      activities: reflowed,
      impact_report: {
        affected_count: 0,
        affected_ids: [],
        changes: [],
        conflicts: [{
          type: "LOCK_VIOLATION",
          activity_id: normalizedId,
          message: `Activity ${normalizedId} is locked and cannot be changed`,
          severity: "error",
        }],
      },
    }
  }
  
  // 7. 재계산 실행
  const changes: DateChange[] = []
  const conflicts: ScheduleConflict[] = []
  
  // 변경된 활동 업데이트
  const oldStart = changed.planned_start
  const oldFinish = changed.planned_finish
  const newFinish = calculateFinishDate(newStartDate, changed.duration)
  
  const changedIndex = reflowed.findIndex(a => normalizeActivityId(a) === normalizedId)
  reflowed[changedIndex] = {
    ...reflowed[changedIndex],
    planned_start: newStartDate,
    planned_finish: newFinish,
  }
  
  changes.push({
    activity_id: normalizedId,
    old_start: oldStart,
    new_start: newStartDate,
    old_finish: oldFinish,
    new_finish: newFinish,
    delta_days: diffUTCDays(oldStart, newStartDate),
  })
  
  // 8. 후속 활동 재계산 (토폴로지 순서)
  const affectedIds = getAffectedActivities(graph, normalizedId, leafIds)
  const sortedAffected = topologicalSort(graph, affectedIds, leafIds)
  
  for (const activityId of sortedAffected) {
    if (activityId === normalizedId) continue
    
    const activity = leafActivities.find(a => normalizeActivityId(a) === activityId)
    if (!activity) continue
    
    // Lock 검사
    if (options.respectLocks && activity.is_locked) {
      conflicts.push({
        type: "LOCK_VIOLATION",
        activity_id: activityId,
        message: `Activity ${activityId} is locked, cannot reschedule`,
        severity: "warn",
      })
      continue
    }
    
    // preserveOffset 모드
    if (options.preserveOffset) {
      // 오프셋 유지 로직
      const offset = diffUTCDays(activity.planned_start, oldStart)
      const newDates = {
        start: addUTCDays(parseUTCDate(newStartDate), offset).toISOString().split("T")[0],
        finish: calculateFinishDate(/* ... */),
      }
      // ... 업데이트
    } else {
      // 의존성 기반 계산
      const newDates = calculateDependentDates(
        activity,
        reflowed.filter(a => leafIds.has(normalizeActivityId(a))),
        graph,
        options.preserveOffset ? parseUTCDate(oldStart) : undefined
      )
      
      // Constraint 검증
      if (options.respectConstraints && activity.constraint) {
        const constraintCheck = validateConstraint(activity, newDates)
        if (!constraintCheck.valid) {
          conflicts.push({
            type: "CONSTRAINT",
            activity_id: activityId,
            message: constraintCheck.message || "Constraint violation",
            severity: "error",
          })
          continue
        }
      }
      
      // 업데이트
      const activityIndex = reflowed.findIndex(a => normalizeActivityId(a) === activityId)
      const oldStart = reflowed[activityIndex].planned_start
      const oldFinish = reflowed[activityIndex].planned_finish
      
      reflowed[activityIndex] = {
        ...reflowed[activityIndex],
        planned_start: newDates.start,
        planned_finish: newDates.finish,
      }
      
      changes.push({
        activity_id: activityId,
        old_start: oldStart,
        new_start: newDates.start,
        old_finish: oldFinish,
        new_finish: newDates.finish,
        delta_days: diffUTCDays(oldStart, newDates.start),
      })
    }
  }
  
  // 9. SUMMARY 활동 rollup (자식의 min/max)
  rollupSummaryActivities(reflowed)
  
  // 10. 자원 충돌 검사
  if (options.checkResourceConflicts) {
    const resourceConflicts = detectResourceConflicts(
      reflowed.filter(a => leafIds.has(normalizeActivityId(a)))
    )
    conflicts.push(...resourceConflicts)
  }
  
  return {
    activities: reflowed,
    impact_report: {
      affected_count: changes.length,
      affected_ids: changes.map(c => c.activity_id),
      changes,
      conflicts,
    },
  }
}

/**
 * 의존성 사이클 탐지 (DFS 기반)
 */
function detectDependencyCycles(
  graph: Map<string, ScheduleDependency[]>,
  validIds: Set<string>
): string[][] {
  const cycles: string[][] = []
  const visited = new Set<string>()
  const recursionStack = new Set<string>()
  const path: string[] = []
  
  function visit(node: string) {
    if (recursionStack.has(node)) {
      // 사이클 발견
      const cycleStart = path.indexOf(node)
      cycles.push([...path.slice(cycleStart), node])
      return
    }
    
    if (visited.has(node)) return
    
    visited.add(node)
    recursionStack.add(node)
    path.push(node)
    
    const deps = graph.get(node) || []
    for (const dep of deps) {
      if (validIds.has(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
    
    recursionStack.delete(node)
    path.pop()
  }
  
  for (const node of validIds) {
    if (!visited.has(node)) {
      visit(node)
    }
  }
  
  return cycles
}

/**
 * SUMMARY 활동 rollup (자식의 min/max)
 */
function rollupSummaryActivities(activities: ScheduleActivity[]): void {
  // level1/level2 기준으로 그룹화
  const summaryMap = new Map<string, ScheduleActivity[]>()
  
  for (const activity of activities) {
    if (activity.activity_id === null) {
      const key = `${activity.level1}_${activity.level2 || "ROOT"}`
      if (!summaryMap.has(key)) {
        summaryMap.set(key, [])
      }
    }
  }
  
  // 각 SUMMARY의 자식 찾기
  for (const [key, summaries] of summaryMap.entries()) {
    for (const summary of summaries) {
      const children = activities.filter(a => 
        a.activity_id !== null &&
        a.level1 === summary.level1 &&
        (summary.level2 === null || a.level2 === summary.level2)
      )
      
      if (children.length > 0) {
        const starts = children.map(c => parseUTCDate(c.planned_start))
        const finishes = children.map(c => parseUTCDate(c.planned_finish))
        
        summary.planned_start = new Date(Math.min(...starts.map(d => d.getTime())))
          .toISOString().split("T")[0]
        summary.planned_finish = new Date(Math.max(...finishes.map(d => d.getTime())))
          .toISOString().split("T")[0]
      }
    }
  }
}
```

---

## 3. option_c.json → SSOT 매핑 규칙

의존성/앵커 매핑 규칙 정의.

```typescript
/**
 * option_c.json → ScheduleActivity 매핑 규칙
 * 
 * 1. activity_id null → SUMMARY로 분류
 * 2. TR Unit 추출 규칙: activity_name에서 "TR Unit N" 패턴
 * 3. Anchor 타입 추출: activity_name 키워드 매칭
 * 4. 자원 태그 추출: activity_name에서 "Crane", "Forklift" 등
 */
export function mapOptionCToScheduleActivity(
  raw: any,
  index: number
): ScheduleActivity {
  const isSummary = raw.activity_id === null
  
  // TR Unit 추출
  const trUnitMatch = raw.activity_name.match(/TR Unit (\d+)/i)
  const trUnitId = trUnitMatch
    ? (`TR-${trUnitMatch[1]}` as TRUnitId)
    : undefined
  
  // Anchor 타입 추출
  const anchorType = extractAnchorType(raw.activity_name, raw.level2)
  
  // 자원 태그 추출
  const resourceTags = extractResourceTags(raw.activity_name)
  
  return {
    ...raw,
    _is_summary: isSummary,
    tr_unit_id: trUnitId,
    anchor_type: anchorType,
    resource_tags: resourceTags,
  }
}

function extractAnchorType(name: string, level2: string | null): AnchorType | undefined {
  const lower = name.toLowerCase()
  if (lower.includes("load-out") || lower.includes("loadout")) return "LOADOUT"
  if (lower.includes("sail") || lower.includes("lct")) return "SAIL_AWAY"
  if (lower.includes("berth") || lower.includes("arrival")) return "BERTHING"
  if (lower.includes("load-in") || lower.includes("loadin")) return "LOADIN"
  if (lower.includes("turning")) return "TURNING"
  if (lower.includes("jack") || lower.includes("jd")) return "JACKDOWN"
  return undefined
}

function extractResourceTags(name: string): string[] {
  const tags: string[] = []
  const lower = name.toLowerCase()
  if (lower.includes("crane")) tags.push("CRANE")
  if (lower.includes("forklift")) {
    if (lower.includes("5t") || lower.includes("5 t")) tags.push("FORKLIFT_5T")
    if (lower.includes("10t") || lower.includes("10 t")) tags.push("FORKLIFT_10T")
  }
  if (lower.includes("spmt")) tags.push("SPMT")
  return tags
}
```

---

## 우선순위별 실행 계획

| 우선순위 | 작업 | 예상 시간 |
|---------|------|----------|
| P0 | SSOT 타입에 요약행/일수 규칙 명문화 | 1시간 |
| P0 | 순수 함수 개선 (불변성 보장) | 2시간 |
| P1 | UTC 날짜 연산 적용 | 1시간 |
| P1 | 사이클 탐지 구현 | 1시간 |
| P2 | Lock/Constraint 제대로 처리 | 2시간 |
| P2 | preserveOffset 모드 구현 | 2시간 |
| P3 | option_c.json 매핑 규칙 | 1시간 |

---

제안한 개선안 중 어느 것부터 진행할까요? Agent 모드로 전환하시면 파일 생성 및 수정을 진행하겠습니다.1