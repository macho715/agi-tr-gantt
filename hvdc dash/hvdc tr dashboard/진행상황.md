
`next.config.mjs` 수정 확인. 타입 안전성이 활성화되었습니다.

---

## 완료된 작업

| 작업                        | 상태 | 비고                       |
| --------------------------- | ---- | -------------------------- |
| `typecheck` 스크립트 추가 | 완료 | `package.json`           |
| `next.config.mjs` 수정    | 완료 | `ignoreBuildErrors` 제거 |

---

## 패키지 매니저 결정

`.cursor/rules/020-commands-autodetect.mdc` 규칙 기준:

```
✅ pnpm-lock.yaml 존재 → pnpm 사용 권장
```

결론: pnpm 사용 권장

---

## 실행 방법

### Option A: pnpm 사용 (권장)

```bash
# 1. 의존성 설치
pnpm install

# 2. 타입 체크 실행
pnpm run typecheck

# 3. (선택) 감시 모드
pnpm run typecheck:watch
```

### Option B: npm 사용 (대체)

```bash
# 1. 의존성 설치
npm install

# 2. 타입 체크 실행
npm run typecheck
```

> 참고: `pnpm-lock.yaml`이 있으면 pnpm 사용을 권장합니다.

---

## 타입 체크 결과에 따른 조치

### 시나리오 A: 타입 에러 없음 (0개)

```
✅ TypeScript check passed!
```

다음 단계:

1. `pnpm run build` 테스트
2. 모든 검증 게이트 통과 확인

---

### 시나리오 B: 타입 에러 있음 (1개 이상)

```
❌ Error: [파일경로]:[라인] - [에러메시지]
```

다음 단계:

1. 에러 목록 확인
2. 각 에러 수정
3. `pnpm run typecheck` 재실행

---

## 최종 검증 체크리스트

| 단계 | 명령어/작업                | 상태                    |
| ---- | -------------------------- | ----------------------- |
| 1    | `pnpm install`           | ⏳ 대기                 |
| 2    | `pnpm run typecheck`     | ⏳ 대기                 |
| 3    | 타입 에러 수정 (있는 경우) | ⏳ 대기                 |
| 4    | `pnpm run build`         | ⏳ 대기                 |
| 5    | `pnpm run lint`          | ✅ 가능 (스크립트 존재) |

---

## 규칙 준수 상태

| 규칙                                          | 항목                   | 상태                   |
| --------------------------------------------- | ---------------------- | ---------------------- |
| `agent.md` §2.3                            | 검증 게이트 통과       | ✅ 활성화됨            |
| `agent.md` §3.4                            | TypeScript 필수 게이트 | ✅ 준비 완료           |
| `.cursor/rules/060-qa-gates.mdc`            | 검증 파이프라인        | ✅ typecheck 포함 가능 |
| `.cursor/rules/020-commands-autodetect.mdc` | PM 확정                | ✅ pnpm                |

---

## 추가 확인 사항

### `tools/run_validate.mjs` 자동 실행

`.cursor/config/workspace.json`에 정의된 `/validate` 명령이 이제 `typecheck`도 실행합니다:

```javascript
// tools/run_validate.mjs
for (const key of ["lint", "typecheck", "tsc", "check", "test", "build"]) {
  // typecheck 스크립트 존재 → 자동 실행
}
```

---

## 다음 단계 요약

1. 의존성 설치:

   ```bash
   pnpm install
   ```
2. 타입 체크 실행:

   ```bash
   pnpm run typecheck
   ```
3. 결과 확인:

   - 성공 시: 빌드 테스트 진행
   - 에러 발견 시: 에러 목록 확인 후 수정
4. 최종 검증:

   ```bash
   pnpm run build
   ```

---

`pnpm install` 후 `pnpm run typecheck` 실행 결과를 공유해 주시면, 타입 에러가 있는 경우 수정안을 제안하겠습니다.

완료되었습니다. 타입 안전성이 활성화되었습니다.

---

# 스케줄 엔진 구현 설계 (Dependency-based Re-scheduling)

## 현재 데이터 구조 분석

| 항목                      | 현재 상태                                                                      | 확장 필요           |
| ------------------------- | ------------------------------------------------------------------------------ | ------------------- |
| `option_c.json`         | `activities[]` (level1, level2, activity_id, duration, planned_start/finish) | ✅ 의존성 필드 추가 |
| `lib/dashboard-data.ts` | 간단한 `Activity` 타입                                                       | ⚠️ 확장 필요      |
| SSOT 구조                 | 미구현                                                                         | ✅ 새로 생성        |

---

## 구현 구조 (agent.md 규칙 준수)

### 1. SSOT 타입 정의 (`lib/ssot/schedule.ts` 또는 `src/lib/ssot/schedule.ts`)

```typescript
// lib/ssot/schedule.ts

export type DependencyType = "FS" | "SS" | "FF" | "SF"  // Finish-to-Start, Start-to-Start, etc.
export type AnchorType = "LOADOUT" | "SAIL_AWAY" | "BERTHING" | "LOADIN" | "TURNING" | "JACKDOWN"

export interface ScheduleDependency {
  predecessorId: string
  type: DependencyType
  lagDays: number  // 오프셋 (일 단위)
}

export interface ScheduleConstraint {
  type: "START_NO_EARLIER_THAN" | "FINISH_NO_LATER_THAN" | "MUST_START_ON" | "MUST_FINISH_ON"
  date: string  // ISO date
  reason?: string
}

export interface ScheduleActivity {
  // 기존 필드
  activity_id: string | null
  activity_name: string
  level1: string
  level2: string | null
  duration: number
  planned_start: string
  planned_finish: string
  
  // 확장 필드 (스케줄 엔진용)
  tr_unit_id?: "TR-1" | "TR-2" | "TR-3" | "TR-4" | "TR-5" | "TR-6" | "TR-7"
  anchor_type?: AnchorType
  depends_on?: ScheduleDependency[]
  is_locked?: boolean
  constraint?: ScheduleConstraint
  resource_tags?: string[]  // ["CRANE", "FORKLIFT_10T", "SPMT"]
}

export interface ReflowResult {
  activities: ScheduleActivity[]
  impact_report: {
    affected_count: number
    affected_ids: string[]
    changes: Array<{
      activity_id: string
      old_start: string
      new_start: string
      old_finish: string
      new_finish: string
      delta_days: number
    }>
    conflicts: Array<{
      type: "RESOURCE" | "CONSTRAINT" | "LOCK_VIOLATION"
      activity_id: string
      message: string
      severity: "warn" | "error"
    }>
  }
}
```

---

### 2. 재계산 엔진 (`lib/utils/schedule-reflow.ts`)

```typescript
// lib/utils/schedule-reflow.ts

import type { ScheduleActivity, ReflowResult, ScheduleDependency } from "@/lib/ssot/schedule"

/**
 * 의존성 그래프 기반 스케줄 재계산
 * 규칙: 순수 함수 (렌더링/DOM/상태관리 금지)
 */
export function reflowSchedule(
  activities: ScheduleActivity[],
  changedActivityId: string,
  newStartDate: string,
  options?: {
    preserveOffset?: boolean  // 방식 1: 오프셋 유지 모드
    respectLocks?: boolean
    respectConstraints?: boolean
  }
): ReflowResult {
  // 1. 의존성 그래프 빌드
  const graph = buildDependencyGraph(activities)
  
  // 2. 변경된 활동 찾기
  const changed = activities.find(a => a.activity_id === changedActivityId)
  if (!changed) {
    throw new Error(`Activity ${changedActivityId} not found`)
  }
  
  // 3. 영향받는 활동 식별 (토폴로지 순서)
  const affectedIds = getAffectedActivities(graph, changedActivityId)
  
  // 4. 재계산 (토폴로지 정렬 후 순차 계산)
  const reflowed = [...activities]
  const changes: ReflowResult["impact_report"]["changes"] = []
  const conflicts: ReflowResult["impact_report"]["conflicts"] = []
  
  // 변경된 활동 업데이트
  const oldStart = changed.planned_start
  const oldFinish = changed.planned_finish
  const newFinish = calculateFinishDate(newStartDate, changed.duration)
  
  reflowed.forEach(a => {
    if (a.activity_id === changedActivityId) {
      a.planned_start = newStartDate
      a.planned_finish = newFinish
      changes.push({
        activity_id: a.activity_id,
        old_start: oldStart,
        new_start: newStartDate,
        old_finish: oldFinish,
        new_finish: newFinish,
        delta_days: calculateDeltaDays(oldStart, newStartDate)
      })
    }
  })
  
  // 후속 활동 재계산
  const sortedAffected = topologicalSort(graph, affectedIds)
  for (const activityId of sortedAffected) {
    if (activityId === changedActivityId) continue
  
    const activity = reflowed.find(a => a.activity_id === activityId)
    if (!activity || activity.is_locked) continue
  
    // 의존성 기반 날짜 계산
    const newDates = calculateDependentDates(activity, reflowed, graph)
  
    // Constraint 검증
    if (options?.respectConstraints && activity.constraint) {
      const constraintCheck = validateConstraint(activity, newDates)
      if (!constraintCheck.valid) {
        conflicts.push({
          type: "CONSTRAINT",
          activity_id: activityId,
          message: constraintCheck.message,
          severity: "error"
        })
        continue
      }
    }
  
    // 업데이트
    const oldStart = activity.planned_start
    const oldFinish = activity.planned_finish
    activity.planned_start = newDates.start
    activity.planned_finish = newDates.finish
  
    changes.push({
      activity_id: activityId,
      old_start: oldStart,
      new_start: newDates.start,
      old_finish: oldFinish,
      new_finish: newDates.finish,
      delta_days: calculateDeltaDays(oldStart, newDates.start)
    })
  }
  
  // 자원 충돌 검사
  if (options?.respectConstraints) {
    const resourceConflicts = detectResourceConflicts(reflowed)
    conflicts.push(...resourceConflicts)
  }
  
  return {
    activities: reflowed,
    impact_report: {
      affected_count: changes.length,
      affected_ids: changes.map(c => c.activity_id),
      changes,
      conflicts
    }
  }
}

/**
 * 의존성 그래프 빌드 (Map<activityId, dependencies[]>)
 */
function buildDependencyGraph(activities: ScheduleActivity[]): Map<string, ScheduleDependency[]> {
  const graph = new Map<string, ScheduleDependency[]>()
  
  for (const activity of activities) {
    if (!activity.activity_id) continue
    graph.set(activity.activity_id, activity.depends_on || [])
  }
  
  return graph
}

/**
 * 영향받는 활동 식별 (후속 활동만)
 */
function getAffectedActivities(
  graph: Map<string, ScheduleDependency[]>,
  changedId: string
): string[] {
  const affected = new Set<string>()
  const queue = [changedId]
  
  while (queue.length > 0) {
    const current = queue.shift()!
    affected.add(current)
  
    // 모든 활동에서 현재 활동을 의존하는 것 찾기
    for (const [activityId, deps] of graph.entries()) {
      if (deps.some(d => d.predecessorId === current)) {
        if (!affected.has(activityId)) {
          queue.push(activityId)
        }
      }
    }
  }
  
  return Array.from(affected)
}

/**
 * 토폴로지 정렬 (의존성 순서)
 */
function topologicalSort(
  graph: Map<string, ScheduleDependency[]>,
  activityIds: string[]
): string[] {
  // 간단한 구현 (DFS 기반)
  const sorted: string[] = []
  const visited = new Set<string>()
  
  function visit(id: string) {
    if (visited.has(id)) return
    visited.add(id)
  
    const deps = graph.get(id) || []
    for (const dep of deps) {
      if (activityIds.includes(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
  
    sorted.push(id)
  }
  
  for (const id of activityIds) {
    visit(id)
  }
  
  return sorted
}

/**
 * 의존성 기반 날짜 계산
 */
function calculateDependentDates(
  activity: ScheduleActivity,
  allActivities: ScheduleActivity[],
  graph: Map<string, ScheduleDependency[]>
): { start: string; finish: string } {
  const deps = graph.get(activity.activity_id || "") || []
  
  let earliestStart = activity.planned_start
  
  for (const dep of deps) {
    const predecessor = allActivities.find(a => a.activity_id === dep.predecessorId)
    if (!predecessor) continue
  
    let depDate: string
  
    switch (dep.type) {
      case "FS":  // Finish-to-Start
        depDate = addDays(predecessor.planned_finish, dep.lagDays)
        break
      case "SS":  // Start-to-Start
        depDate = addDays(predecessor.planned_start, dep.lagDays)
        break
      case "FF":  // Finish-to-Finish
        depDate = addDays(predecessor.planned_finish, dep.lagDays - activity.duration)
        break
      case "SF":  // Start-to-Finish
        depDate = addDays(predecessor.planned_start, dep.lagDays - activity.duration)
        break
      default:
        depDate = earliestStart
    }
  
    if (compareDates(depDate, earliestStart) > 0) {
      earliestStart = depDate
    }
  }
  
  return {
    start: earliestStart,
    finish: calculateFinishDate(earliestStart, activity.duration)
  }
}

/**
 * 자원 충돌 탐지
 */
function detectResourceConflicts(activities: ScheduleActivity[]): ReflowResult["impact_report"]["conflicts"] {
  const conflicts: ReflowResult["impact_report"]["conflicts"] = []
  const resourceMap = new Map<string, Array<{ id: string; start: string; finish: string }>>()
  
  // 자원별 활동 그룹화
  for (const activity of activities) {
    if (!activity.activity_id || !activity.resource_tags) continue
  
    for (const resource of activity.resource_tags) {
      if (!resourceMap.has(resource)) {
        resourceMap.set(resource, [])
      }
      resourceMap.get(resource)!.push({
        id: activity.activity_id,
        start: activity.planned_start,
        finish: activity.planned_finish
      })
    }
  }
  
  // 시간 겹침 검사
  for (const [resource, activities] of resourceMap.entries()) {
    for (let i = 0; i < activities.length; i++) {
      for (let j = i + 1; j < activities.length; j++) {
        const a1 = activities[i]
        const a2 = activities[j]
      
        if (datesOverlap(a1.start, a1.finish, a2.start, a2.finish)) {
          conflicts.push({
            type: "RESOURCE",
            activity_id: a1.id,
            message: `Resource conflict: ${resource} is required by both ${a1.id} and ${a2.id}`,
            severity: "warn"
          })
        }
      }
    }
  }
  
  return conflicts
}

// 유틸 함수들
function addDays(dateStr: string, days: number): string {
  const date = new Date(dateStr)
  date.setDate(date.getDate() + days)
  return date.toISOString().split("T")[0]
}

function calculateFinishDate(startStr: string, duration: number): string {
  return addDays(startStr, Math.ceil(duration) - 1)
}

function calculateDeltaDays(oldDate: string, newDate: string): number {
  const old = new Date(oldDate)
  const new_ = new Date(newDate)
  return Math.ceil((new_.getTime() - old.getTime()) / (1000 * 60 * 60 * 24))
}

function compareDates(date1: string, date2: string): number {
  return new Date(date1).getTime() - new Date(date2).getTime()
}

function datesOverlap(start1: string, finish1: string, start2: string, finish2: string): boolean {
  return new Date(start1) <= new Date(finish2) && new Date(start2) <= new Date(finish1)
}

function validateConstraint(
  activity: ScheduleActivity,
  newDates: { start: string; finish: string }
): { valid: boolean; message?: string } {
  if (!activity.constraint) return { valid: true }
  
  const constraint = activity.constraint
  const constraintDate = new Date(constraint.date)
  const newStart = new Date(newDates.start)
  const newFinish = new Date(newDates.finish)
  
  switch (constraint.type) {
    case "START_NO_EARLIER_THAN":
      if (newStart < constraintDate) {
        return { valid: false, message: `Start date must be no earlier than ${constraint.date}` }
      }
      break
    case "FINISH_NO_LATER_THAN":
      if (newFinish > constraintDate) {
        return { valid: false, message: `Finish date must be no later than ${constraint.date}` }
      }
      break
    case "MUST_START_ON":
      if (newStart.toISOString().split("T")[0] !== constraint.date) {
        return { valid: false, message: `Must start on ${constraint.date}` }
      }
      break
    case "MUST_FINISH_ON":
      if (newFinish.toISOString().split("T")[0] !== constraint.date) {
        return { valid: false, message: `Must finish on ${constraint.date}` }
      }
      break
  }
  
  return { valid: true }
}
```

---

### 3. UI 컴포넌트 (`components/gantt/ScheduleEditor.tsx`)

```typescript
// components/gantt/ScheduleEditor.tsx

"use client"

import { useState } from "react"
import { reflowSchedule } from "@/lib/utils/schedule-reflow"
import type { ScheduleActivity, ReflowResult } from "@/lib/ssot/schedule"

interface ScheduleEditorProps {
  activities: ScheduleActivity[]
  onApply: (result: ReflowResult) => void
  onCancel: () => void
}

export function ScheduleEditor({ activities, onApply, onCancel }: ScheduleEditorProps) {
  const [preview, setPreview] = useState<ReflowResult | null>(null)
  const [selectedActivityId, setSelectedActivityId] = useState<string | null>(null)
  const [newDate, setNewDate] = useState<string>("")
  
  const handleDateChange = (activityId: string, newStartDate: string) => {
    setSelectedActivityId(activityId)
    setNewDate(newStartDate)
  
    // Preview 생성
    const result = reflowSchedule(activities, activityId, newStartDate, {
      respectLocks: true,
      respectConstraints: true
    })
  
    setPreview(result)
  }
  
  const handleApply = () => {
    if (preview) {
      onApply(preview)
      setPreview(null)
    }
  }
  
  return (
    <div className="schedule-editor">
      {/* 날짜 편집 UI */}
      <div className="date-editor">
        {/* 활동 선택 및 날짜 입력 */}
      </div>
    
      {/* Preview 패널 */}
      {preview && (
        <div className="preview-panel">
          <h3>영향받는 작업 ({preview.impact_report.affected_count}개)</h3>
        
          {/* 변경 사항 목록 */}
          <div className="changes-list">
            {preview.impact_report.changes.map(change => (
              <div key={change.activity_id} className="change-item">
                <span>{change.activity_id}</span>
                <span>{change.old_start} → {change.new_start}</span>
                <span className={change.delta_days >= 0 ? "delay" : "ahead"}>
                  {change.delta_days >= 0 ? "+" : ""}{change.delta_days}일
                </span>
              </div>
            ))}
          </div>
        
          {/* 충돌 경고 */}
          {preview.impact_report.conflicts.length > 0 && (
            <div className="conflicts">
              {preview.impact_report.conflicts.map((conflict, idx) => (
                <div key={idx} className={`conflict ${conflict.severity}`}>
                  {conflict.message}
                </div>
              ))}
            </div>
          )}
        
          {/* 적용/취소 버튼 */}
          <div className="actions">
            <button onClick={handleApply}>적용</button>
            <button onClick={onCancel}>취소</button>
          </div>
        </div>
      )}
    </div>
  )
}
```

---

## 구현 우선순위 (P→Pi→B→O→S)

### Phase 1: Prepare (P) - 1일

1. SSOT 타입 정의 (`lib/ssot/schedule.ts`)
2. 기본 의존성 규칙 정의:
   - TR Unit i → TR Unit i+1 연결 규칙
   - Anchor 타입 정의 (Load-out 기본값)

### Phase 2: Pilot (Pi) - 2일

1. 재계산 엔진 기본 구현 (`lib/utils/schedule-reflow.ts`)
2. TR1~TR3 샌드박스 테스트
3. Preview/Diff UI 기본 구현

### Phase 3: Build (B) - 3일

1. Lock/Constraint 처리
2. 자원 충돌 탐지
3. 전체 TR Unit 연쇄 반영

### Phase 4: Operate (O) - 2일

1. Next 7 days 자동 갱신
2. 히스토리 (undo/redo)
3. localStorage 저장

### Phase 5: Scale (S) - 1주

1. 시나리오 플래너
2. 변경 로그
3. 복구 기능

---

## 규칙 준수 확인

| 규칙                                     | 준수 여부 | 비고                                       |
| ---------------------------------------- | --------- | ------------------------------------------ |
| `agent.md` §6.1                       | ✅        | `lib/ssot/`, `lib/utils/` 구조         |
| `agent.md` §6.7                       | ✅        | 계산은 utils, UI는 렌더링만                |
| `.cursor/rules/040-gantt-deadline.mdc` | ✅        | 공통 키 (`tr_unit_id`, `milestone_id`) |
| `.cursor/rules/050-directory-map.mdc`  | ✅        | SSOT 위치 고정                             |

---

## 다음 단계

1. SSOT 타입 정의 파일 생성
2. 재계산 엔진 기본 구현
3. UI 컴포넌트 통합

파일 생성/수정이 필요하면 Agent 모드로 전환해 주세요.

---

## SSOT 타입 정의 파일: `lib/ssot/schedule.ts`

```typescript
/**
 * SSOT (Single Source of Truth) - Schedule Types
 * 
 * 스케줄 엔진(Dependency-based Re-scheduling)을 위한 타입 정의
 * 규칙: 계산 로직은 lib/utils/에, UI는 components/에 분리
 * 
 * @see .cursor/rules/040-gantt-deadline.mdc
 * @see .cursor/rules/050-directory-map.mdc
 */

// ============================================================================
// 1. 기본 Enum 타입
// ============================================================================

/**
 * 의존성 관계 타입
 * - FS: Finish-to-Start (전작업 완료 후 시작)
 * - SS: Start-to-Start (전작업 시작 후 시작)
 * - FF: Finish-to-Finish (전작업 완료 후 완료)
 * - SF: Start-to-Finish (전작업 시작 후 완료)
 */
export type DependencyType = "FS" | "SS" | "FF" | "SF"

/**
 * Anchor 타입 (고정점/마일스톤)
 * TR Unit별 반복 시퀀스의 기준점
 */
export type AnchorType =
  | "LOADOUT"
  | "SAIL_AWAY"
  | "BERTHING"
  | "LOADIN"
  | "TURNING"
  | "JACKDOWN"

/**
 * TR Unit 식별자
 */
export type TRUnitId = "TR-1" | "TR-2" | "TR-3" | "TR-4" | "TR-5" | "TR-6" | "TR-7"

/**
 * 작업 상태
 */
export type ActivityStatus = "planned" | "in_progress" | "blocked" | "done"

// ============================================================================
// 2. 의존성 및 제약 조건
// ============================================================================

/**
 * 의존성 관계 정의
 */
export interface ScheduleDependency {
  /** 선행 작업 ID */
  predecessorId: string
  /** 의존성 타입 */
  type: DependencyType
  /** 오프셋 (일 단위) - 양수: 지연, 음수: 선행 */
  lagDays: number
}

/**
 * 제약 조건 (Constraint)
 */
export interface ScheduleConstraint {
  /** 제약 타입 */
  type:
    | "START_NO_EARLIER_THAN" // 시작일은 이 날짜 이후
    | "FINISH_NO_LATER_THAN" // 완료일은 이 날짜 이전
    | "MUST_START_ON" // 반드시 이 날짜에 시작
    | "MUST_FINISH_ON" // 반드시 이 날짜에 완료
  /** 제약 날짜 (ISO format: YYYY-MM-DD) */
  date: string
  /** 제약 사유 (예: "Berth reservation", "Regulatory deadline") */
  reason?: string
}

/**
 * 캘린더 제약 (주말/공휴일/금지일)
 */
export interface ScheduleCalendar {
  /** 주말 제외 여부 */
  weekendsOff?: boolean
  /** 금지일 목록 (ISO format: YYYY-MM-DD) */
  blackoutDates?: string[]
}

// ============================================================================
// 3. 스케줄 활동 (Schedule Activity)
// ============================================================================

/**
 * 스케줄 활동 (option_c.json 확장 구조)
 * 
 * 기존 필드:
 * - activity_id, activity_name, level1, level2, duration, planned_start, planned_finish
 * 
 * 확장 필드 (스케줄 엔진용):
 * - tr_unit_id, anchor_type, depends_on, is_locked, constraint, resource_tags
 */
export interface ScheduleActivity {
  // 기존 필드 (option_c.json 구조)
  /** 활동 ID (null이면 phase/summary) */
  activity_id: string | null
  /** 활동 이름 */
  activity_name: string
  /** Level 1 (대분류: MOBILIZATION, OPERATIONAL, DEMOBILIZATION 등) */
  level1: string
  /** Level 2 (세부 공정: SPMT, MARINE, Beam Replacement 등) */
  level2: string | null
  /** 기간 (일 단위) */
  duration: number
  /** 계획 시작일 (ISO format: YYYY-MM-DD) */
  planned_start: string
  /** 계획 완료일 (ISO format: YYYY-MM-DD) */
  planned_finish: string

  // 확장 필드 (스케줄 엔진용)
  /** TR Unit 식별자 */
  tr_unit_id?: TRUnitId
  /** Anchor 타입 (마일스톤/고정점) */
  anchor_type?: AnchorType
  /** 의존성 목록 */
  depends_on?: ScheduleDependency[]
  /** 고정(잠금) 여부 - Locked 작업은 날짜 변경 불가 */
  is_locked?: boolean
  /** 제약 조건 */
  constraint?: ScheduleConstraint
  /** 캘린더 제약 */
  calendar?: ScheduleCalendar
  /** 자원 태그 (충돌 탐지용: ["CRANE", "FORKLIFT_10T", "SPMT"] 등) */
  resource_tags?: string[]
  /** 항차 ID (예: "V1", "V2" 등) */
  voyage_id?: string
  /** 마일스톤 ID (예: "MZP_LOADOUT_START") */
  milestone_id?: string
  /** 작업 상태 */
  status?: ActivityStatus
}

// ============================================================================
// 4. 재계산 결과 (Reflow Result)
// ============================================================================

/**
 * 날짜 변경 정보
 */
export interface DateChange {
  /** 활동 ID */
  activity_id: string
  /** 이전 시작일 */
  old_start: string
  /** 새 시작일 */
  new_start: string
  /** 이전 완료일 */
  old_finish: string
  /** 새 완료일 */
  new_finish: string
  /** 변경 일수 (양수: 지연, 음수: 선행) */
  delta_days: number
}

/**
 * 충돌 정보
 */
export interface ScheduleConflict {
  /** 충돌 타입 */
  type: "RESOURCE" | "CONSTRAINT" | "LOCK_VIOLATION" | "DEPENDENCY_CYCLE"
  /** 활동 ID */
  activity_id: string
  /** 충돌 메시지 */
  message: string
  /** 심각도 */
  severity: "warn" | "error"
  /** 관련 활동 ID 목록 (자원 충돌 시) */
  related_activity_ids?: string[]
}

/**
 * 영향 리포트 (Impact Report)
 */
export interface ImpactReport {
  /** 영향받는 활동 수 */
  affected_count: number
  /** 영향받는 활동 ID 목록 */
  affected_ids: string[]
  /** 날짜 변경 목록 */
  changes: DateChange[]
  /** 충돌 목록 */
  conflicts: ScheduleConflict[]
}

/**
 * 재계산 결과
 */
export interface ReflowResult {
  /** 재계산된 활동 목록 */
  activities: ScheduleActivity[]
  /** 영향 리포트 */
  impact_report: ImpactReport
}

// ============================================================================
// 5. 재계산 옵션
// ============================================================================

/**
 * 재계산 옵션
 */
export interface ReflowOptions {
  /** 오프셋 유지 모드 (방식 1: Template Offset Reflow) */
  preserveOffset?: boolean
  /** Lock 작업 존중 */
  respectLocks?: boolean
  /** 제약 조건 존중 */
  respectConstraints?: boolean
  /** 캘린더 제약 존중 */
  respectCalendar?: boolean
  /** 자원 충돌 검사 */
  checkResourceConflicts?: boolean
}

// ============================================================================
// 6. 상수 및 기본값
// ============================================================================

/**
 * TR Unit 간 기본 연결 규칙
 * TR(i) 완료 → TR(i+1) 시작 (FS + lagDays)
 */
export const DEFAULT_TR_CHAIN_RULE: ScheduleDependency = {
  predecessorId: "", // 동적으로 설정
  type: "FS",
  lagDays: 0,
}

/**
 * Anchor 타입 기본값
 */
export const DEFAULT_ANCHOR_TYPE: AnchorType = "LOADOUT"

/**
 * 기본 재계산 옵션
 */
export const DEFAULT_REFLOW_OPTIONS: ReflowOptions = {
  preserveOffset: false,
  respectLocks: true,
  respectConstraints: true,
  respectCalendar: false,
  checkResourceConflicts: true,
}
```

---

## 파일 구조

생성 위치: `lib/ssot/schedule.ts`

현재 디렉토리 구조:

```
lib/
├── dashboard-data.ts
├── utils.ts
└── ssot/              ← 새로 생성
    └── schedule.ts    ← 이 파일
```

---

## 규칙 준수 확인

| 규칙                                        | 준수 여부 | 비고                                                           |
| ------------------------------------------- | --------- | -------------------------------------------------------------- |
| `agent.md` §2.2 SSOT 우선                | ✅        | 단일 파일에서 타입 정의                                        |
| `.cursor/rules/030-ssot-schema-first.mdc` | ✅        | SSOT 위치:`lib/ssot/`                                        |
| `.cursor/rules/050-directory-map.mdc`     | ✅        | `lib/ssot/schedule.ts` 권장 위치                             |
| `.cursor/rules/040-gantt-deadline.mdc`    | ✅        | 공통 키 (`tr_unit_id`, `milestone_id`, `voyage_id`) 포함 |
| TypeScript strict 모드                      | ✅        | 타입 명시적 정의                                               |

---

## 다음 단계

1. 파일 생성: 위 코드를 `lib/ssot/schedule.ts`로 저장
2. 타입 체크 실행: `pnpm run typecheck`
3. 재계산 엔진 구현: `lib/utils/schedule-reflow.ts` (다음 단계)

---

파일 생성이 필요하면 Agent 모드로 전환하거나, 위 코드를 복사해 `lib/ssot/schedule.ts`에 저장하세요.

`lib/ssot/` 디렉토리가 없으면 먼저 생성하세요.
