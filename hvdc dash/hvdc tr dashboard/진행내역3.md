SSOT 타입 정의 파일 생성 확인. 다음 단계 구현안 제시 중입니다.

---

## 다음 단계: 순수 재계산 엔진 구현

`lib/utils/schedule-reflow.ts` 구현안입니다. 불변성, 사이클 탐지, Lock/Constraint 처리, UTC 날짜 연산을 포함합니다.

```typescript
/**
 * Schedule Reflow Engine (순수 함수)
 * 
 * 규칙 준수:
 * - 불변성 보장 (깊은 복사)
 * - 순수 함수 (부작용 없음)
 * - UTC 날짜 연산
 * - 사이클 탐지
 * - Lock/Constraint 처리
 * 
 * @see lib/ssot/schedule.ts
 */

import type {
  ScheduleActivity,
  ScheduleDependency,
  ReflowResult,
  ReflowOptions,
  DateChange,
  ScheduleConflict,
  DEFAULT_REFLOW_OPTIONS,
} from "@/lib/ssot/schedule"
import {
  normalizeActivityId,
  parseUTCDate,
  addUTCDays,
  diffUTCDays,
  calculateFinishDate,
  DEFAULT_REFLOW_OPTIONS as DEFAULT_OPTIONS,
} from "@/lib/ssot/schedule"

/**
 * 의존성 그래프 기반 스케줄 재계산 (순수 함수)
 */
export function reflowSchedule(
  activities: ScheduleActivity[],
  changedActivityId: string,
  newStartDate: string,
  options: ReflowOptions = DEFAULT_OPTIONS
): ReflowResult {
  const opts = { ...DEFAULT_OPTIONS, ...options }
  
  // 1. 깊은 복사 (불변성 보장)
  const reflowed = deepCopyActivities(activities)
  
  // 2. LEAF 활동만 필터링 (SUMMARY 제외)
  const leafActivities = reflowed.filter(a => a.activity_id !== null)
  const leafIds = new Set(leafActivities.map(a => normalizeActivityId(a)))
  
  // 3. 의존성 그래프 빌드 (LEAF만)
  const graph = buildDependencyGraph(leafActivities)
  
  // 4. 사이클 탐지
  if (opts.detectCycles !== false) {
    const cycles = detectDependencyCycles(graph, leafIds)
    if (cycles.length > 0) {
      return {
        activities: reflowed,
        impact_report: {
          affected_count: 0,
          affected_ids: [],
          changes: [],
          conflicts: cycles.map(cycle => ({
            type: "DEPENDENCY_CYCLE",
            activity_id: cycle[0],
            message: `Circular dependency detected: ${cycle.join(" → ")}`,
            severity: "error",
            related_activity_ids: cycle,
          })),
        },
      }
    }
  }
  
  // 5. 변경된 활동 검증
  const normalizedId = findNormalizedId(changedActivityId, leafIds, leafActivities)
  if (!normalizedId) {
    throw new Error(`Activity ${changedActivityId} not found or is SUMMARY`)
  }
  
  const changed = leafActivities.find(a => normalizeActivityId(a) === normalizedId)
  if (!changed) {
    throw new Error(`Activity ${normalizedId} not found`)
  }
  
  // 6. Lock 검증
  if (opts.respectLocks && changed.is_locked) {
    return {
      activities: reflowed,
      impact_report: {
        affected_count: 0,
        affected_ids: [],
        changes: [],
        conflicts: [{
          type: "LOCK_VIOLATION",
          activity_id: normalizedId,
          message: `Activity ${normalizedId} is locked and cannot be changed`,
          severity: "error",
        }],
      },
    }
  }
  
  // 7. 재계산 실행
  const changes: DateChange[] = []
  const conflicts: ScheduleConflict[] = []
  
  // 변경된 활동 업데이트
  const oldStart = changed.planned_start
  const oldFinish = changed.planned_finish
  const newFinish = calculateFinishDate(newStartDate, changed.duration)
  
  updateActivityDate(reflowed, normalizedId, newStartDate, newFinish)
  
  changes.push({
    activity_id: normalizedId,
    old_start: oldStart,
    new_start: newStartDate,
    old_finish: oldFinish,
    new_finish: newFinish,
    delta_days: diffUTCDays(oldStart, newStartDate),
  })
  
  // 8. 후속 활동 재계산 (토폴로지 순서)
  const affectedIds = getAffectedActivities(graph, normalizedId, leafIds)
  const sortedAffected = topologicalSort(graph, affectedIds, leafIds)
  
  for (const activityId of sortedAffected) {
    if (activityId === normalizedId) continue
    
    const activity = leafActivities.find(a => normalizeActivityId(a) === activityId)
    if (!activity) continue
    
    // Lock 검사
    if (opts.respectLocks && activity.is_locked) {
      conflicts.push({
        type: "LOCK_VIOLATION",
        activity_id: activityId,
        message: `Activity ${activityId} is locked, cannot reschedule`,
        severity: "warn",
      })
      continue
    }
    
    // preserveOffset 모드
    if (opts.preserveOffset) {
      const offset = diffUTCDays(activity.planned_start, oldStart)
      const newStart = addUTCDays(parseUTCDate(newStartDate), offset)
        .toISOString().split("T")[0]
      const newFinish = calculateFinishDate(newStart, activity.duration)
      
      const oldStart = activity.planned_start
      const oldFinish = activity.planned_finish
      
      updateActivityDate(reflowed, activityId, newStart, newFinish)
      
      changes.push({
        activity_id: activityId,
        old_start: oldStart,
        new_start: newStart,
        old_finish: oldFinish,
        new_finish: newFinish,
        delta_days: diffUTCDays(oldStart, newStart),
      })
    } else {
      // 의존성 기반 계산
      const newDates = calculateDependentDates(
        activity,
        leafActivities.map(a => {
          const normalized = normalizeActivityId(a)
          const updated = reflowed.find(r => normalizeActivityId(r) === normalized)
          return updated || a
        }),
        graph
      )
      
      // Constraint 검증
      if (opts.respectConstraints && activity.constraint) {
        const constraintCheck = validateConstraint(activity, newDates)
        if (!constraintCheck.valid) {
          conflicts.push({
            type: "CONSTRAINT",
            activity_id: activityId,
            message: constraintCheck.message || "Constraint violation",
            severity: "error",
          })
          continue
        }
      }
      
      // 업데이트
      const activityIndex = reflowed.findIndex(a => normalizeActivityId(a) === activityId)
      const oldStart = reflowed[activityIndex].planned_start
      const oldFinish = reflowed[activityIndex].planned_finish
      
      reflowed[activityIndex] = {
        ...reflowed[activityIndex],
        planned_start: newDates.start,
        planned_finish: newDates.finish,
      }
      
      changes.push({
        activity_id: activityId,
        old_start: oldStart,
        new_start: newDates.start,
        old_finish: oldFinish,
        new_finish: newDates.finish,
        delta_days: diffUTCDays(oldStart, newDates.start),
      })
    }
  }
  
  // 9. SUMMARY 활동 rollup (자식의 min/max)
  rollupSummaryActivities(reflowed)
  
  // 10. 자원 충돌 검사
  if (opts.checkResourceConflicts) {
    const resourceConflicts = detectResourceConflicts(
      reflowed.filter(a => leafIds.has(normalizeActivityId(a)))
    )
    conflicts.push(...resourceConflicts)
  }
  
  return {
    activities: reflowed,
    impact_report: {
      affected_count: changes.length,
      affected_ids: changes.map(c => c.activity_id),
      changes,
      conflicts,
    },
  }
}

// ============================================================================
// 내부 유틸 함수
// ============================================================================

/**
 * 깊은 복사 (불변성 보장)
 */
function deepCopyActivities(activities: ScheduleActivity[]): ScheduleActivity[] {
  return activities.map(a => ({
    ...a,
    depends_on: a.depends_on ? a.depends_on.map(d => ({ ...d })) : undefined,
    constraint: a.constraint ? { ...a.constraint } : undefined,
    calendar: a.calendar ? { ...a.calendar } : undefined,
    resource_tags: a.resource_tags ? [...a.resource_tags] : undefined,
  }))
}

/**
 * 의존성 그래프 빌드
 */
function buildDependencyGraph(
  activities: ScheduleActivity[]
): Map<string, ScheduleDependency[]> {
  const graph = new Map<string, ScheduleDependency[]>()
  
  for (const activity of activities) {
    const id = normalizeActivityId(activity)
    graph.set(id, activity.depends_on || [])
  }
  
  return graph
}

/**
 * 의존성 사이클 탐지 (DFS 기반)
 */
function detectDependencyCycles(
  graph: Map<string, ScheduleDependency[]>,
  validIds: Set<string>
): string[][] {
  const cycles: string[][] = []
  const visited = new Set<string>()
  const recursionStack = new Set<string>()
  const path: string[] = []
  
  function visit(node: string) {
    if (recursionStack.has(node)) {
      // 사이클 발견
      const cycleStart = path.indexOf(node)
      cycles.push([...path.slice(cycleStart), node])
      return
    }
    
    if (visited.has(node)) return
    
    visited.add(node)
    recursionStack.add(node)
    path.push(node)
    
    const deps = graph.get(node) || []
    for (const dep of deps) {
      if (validIds.has(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
    
    recursionStack.delete(node)
    path.pop()
  }
  
  for (const node of validIds) {
    if (!visited.has(node)) {
      visit(node)
    }
  }
  
  return cycles
}

/**
 * 영향받는 활동 식별 (후속 활동만)
 */
function getAffectedActivities(
  graph: Map<string, ScheduleDependency[]>,
  changedId: string,
  validIds: Set<string>
): Set<string> {
  const affected = new Set<string>()
  const queue = [changedId]
  
  while (queue.length > 0) {
    const current = queue.shift()!
    if (!affected.has(current)) {
      affected.add(current)
      
      // 모든 활동에서 현재 활동을 의존하는 것 찾기
      for (const [activityId, deps] of graph.entries()) {
        if (deps.some(d => d.predecessorId === current) && validIds.has(activityId)) {
          if (!affected.has(activityId)) {
            queue.push(activityId)
          }
        }
      }
    }
  }
  
  return affected
}

/**
 * 토폴로지 정렬 (의존성 순서)
 */
function topologicalSort(
  graph: Map<string, ScheduleDependency[]>,
  activityIds: Set<string>,
  validIds: Set<string>
): string[] {
  const sorted: string[] = []
  const visited = new Set<string>()
  
  function visit(id: string) {
    if (visited.has(id) || !activityIds.has(id)) return
    visited.add(id)
    
    const deps = graph.get(id) || []
    for (const dep of deps) {
      if (validIds.has(dep.predecessorId) && activityIds.has(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
    
    sorted.push(id)
  }
  
  for (const id of activityIds) {
    visit(id)
  }
  
  return sorted
}

/**
 * 의존성 기반 날짜 계산
 */
function calculateDependentDates(
  activity: ScheduleActivity,
  allActivities: ScheduleActivity[],
  graph: Map<string, ScheduleDependency[]>
): { start: string; finish: string } {
  const id = normalizeActivityId(activity)
  const deps = graph.get(id) || []
  
  let earliestStart = parseUTCDate(activity.planned_start)
  
  for (const dep of deps) {
    const predecessor = allActivities.find(a => normalizeActivityId(a) === dep.predecessorId)
    if (!predecessor) continue
    
    let depDate: Date
    
    switch (dep.type) {
      case "FS":  // Finish-to-Start
        depDate = addUTCDays(parseUTCDate(predecessor.planned_finish), dep.lagDays)
        break
      case "SS":  // Start-to-Start
        depDate = addUTCDays(parseUTCDate(predecessor.planned_start), dep.lagDays)
        break
      case "FF":  // Finish-to-Finish
        depDate = addUTCDays(
          parseUTCDate(predecessor.planned_finish),
          dep.lagDays - Math.ceil(activity.duration)
        )
        break
      case "SF":  // Start-to-Finish
        depDate = addUTCDays(
          parseUTCDate(predecessor.planned_start),
          dep.lagDays - Math.ceil(activity.duration)
        )
        break
      default:
        depDate = earliestStart
    }
    
    if (depDate.getTime() > earliestStart.getTime()) {
      earliestStart = depDate
    }
  }
  
  const startStr = earliestStart.toISOString().split("T")[0]
  return {
    start: startStr,
    finish: calculateFinishDate(startStr, activity.duration),
  }
}

/**
 * 제약 조건 검증
 */
function validateConstraint(
  activity: ScheduleActivity,
  newDates: { start: string; finish: string }
): { valid: boolean; message?: string } {
  if (!activity.constraint) return { valid: true }
  
  const constraint = activity.constraint
  const constraintDate = parseUTCDate(constraint.date)
  const newStart = parseUTCDate(newDates.start)
  const newFinish = parseUTCDate(newDates.finish)
  
  switch (constraint.type) {
    case "START_NO_EARLIER_THAN":
      if (newStart < constraintDate) {
        return {
          valid: false,
          message: `Start date must be no earlier than ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "FINISH_NO_LATER_THAN":
      if (newFinish > constraintDate) {
        return {
          valid: false,
          message: `Finish date must be no later than ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "MUST_START_ON":
      if (newDates.start !== constraint.date) {
        return {
          valid: false,
          message: `Must start on ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "MUST_FINISH_ON":
      if (newDates.finish !== constraint.date) {
        return {
          valid: false,
          message: `Must finish on ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
  }
  
  return { valid: true }
}

/**
 * 자원 충돌 탐지
 */
function detectResourceConflicts(activities: ScheduleActivity[]): ScheduleConflict[] {
  const conflicts: ScheduleConflict[] = []
  const resourceMap = new Map<string, Array<{ id: string; start: string; finish: string }>>()
  
  // 자원별 활동 그룹화
  for (const activity of activities) {
    if (!activity.resource_tags) continue
    const id = normalizeActivityId(activity)
    
    for (const resource of activity.resource_tags) {
      if (!resourceMap.has(resource)) {
        resourceMap.set(resource, [])
      }
      resourceMap.get(resource)!.push({
        id,
        start: activity.planned_start,
        finish: activity.planned_finish,
      })
    }
  }
  
  // 시간 겹침 검사
  for (const [resource, activities] of resourceMap.entries()) {
    for (let i = 0; i < activities.length; i++) {
      for (let j = i + 1; j < activities.length; j++) {
        const a1 = activities[i]
        const a2 = activities[j]
        
        if (datesOverlap(a1.start, a1.finish, a2.start, a2.finish)) {
          conflicts.push({
            type: "RESOURCE",
            activity_id: a1.id,
            message: `Resource conflict: ${resource} is required by both ${a1.id} and ${a2.id}`,
            severity: "warn",
            related_activity_ids: [a1.id, a2.id],
          })
        }
      }
    }
  }
  
  return conflicts
}

/**
 * 날짜 겹침 검사
 */
function datesOverlap(start1: string, finish1: string, start2: string, finish2: string): boolean {
  const s1 = parseUTCDate(start1)
  const f1 = parseUTCDate(finish1)
  const s2 = parseUTCDate(start2)
  const f2 = parseUTCDate(finish2)
  return s1 <= f2 && s2 <= f1
}

/**
 * 활동 날짜 업데이트 (불변성 유지)
 */
function updateActivityDate(
  activities: ScheduleActivity[],
  activityId: string,
  newStart: string,
  newFinish: string
): void {
  const index = activities.findIndex(a => normalizeActivityId(a) === activityId)
  if (index >= 0) {
    activities[index] = {
      ...activities[index],
      planned_start: newStart,
      planned_finish: newFinish,
    }
  }
}

/**
 * SUMMARY 활동 rollup (자식의 min/max)
 */
function rollupSummaryActivities(activities: ScheduleActivity[]): void {
  const summaries = activities.filter(a => a.activity_id === null)
  
  for (const summary of summaries) {
    const children = activities.filter(a =>
      a.activity_id !== null &&
      a.level1 === summary.level1 &&
      (summary.level2 === null || a.level2 === summary.level2)
    )
    
    if (children.length > 0) {
      const starts = children.map(c => parseUTCDate(c.planned_start))
      const finishes = children.map(c => parseUTCDate(c.planned_finish))
      
      const minStart = new Date(Math.min(...starts.map(d => d.getTime())))
      const maxFinish = new Date(Math.max(...finishes.map(d => d.getTime())))
      
      summary.planned_start = minStart.toISOString().split("T")[0]
      summary.planned_finish = maxFinish.toISOString().split("T")[0]
    }
  }
}

/**
 * 정규화된 ID 찾기
 */
function findNormalizedId(
  id: string,
  validIds: Set<string>,
  activities: ScheduleActivity[]
): string | null {
  if (validIds.has(id)) return id
  
  // 합성 ID로 시도
  for (const activity of activities) {
    const normalized = normalizeActivityId(activity)
    if (normalized === id) return normalized
  }
  
  return null
}
```

---

## 3. 매핑 규칙 유틸 (`lib/utils/schedule-mapper.ts`)

option_c.json → ScheduleActivity 변환 유틸:

```typescript
/**
 * option_c.json → ScheduleActivity 매핑 유틸
 * 
 * 규칙:
 * - activity_id null → SUMMARY로 분류
 * - TR Unit 추출: "TR Unit N" 패턴
 * - Anchor 타입: 키워드 매칭
 * - 자원 태그: "Crane", "Forklift", "SPMT" 등
 */

import type { ScheduleActivity, AnchorType, TRUnitId } from "@/lib/ssot/schedule"

export function mapOptionCToScheduleActivity(
  raw: any,
  index: number
): ScheduleActivity {
  const isSummary = raw.activity_id === null
  
  // TR Unit 추출
  const trUnitId = extractTRUnitId(raw.activity_name)
  
  // Anchor 타입 추출
  const anchorType = extractAnchorType(raw.activity_name, raw.level2)
  
  // 자원 태그 추출
  const resourceTags = extractResourceTags(raw.activity_name)
  
  // voyage_id 추출 (TR Unit 기반)
  const voyageId = trUnitId ? extractVoyageId(trUnitId) : undefined
  
  return {
    ...raw,
    _is_summary: isSummary,
    tr_unit_id: trUnitId,
    anchor_type: anchorType,
    resource_tags: resourceTags.length > 0 ? resourceTags : undefined,
    voyage_id: voyageId,
  }
}

/**
 * TR Unit ID 추출
 */
function extractTRUnitId(name: string): TRUnitId | undefined {
  const match = name.match(/TR\s*Unit\s*(\d+)/i)
  if (!match) return undefined
  
  const num = parseInt(match[1], 10)
  if (num >= 1 && num <= 7) {
    return `TR-${num}` as TRUnitId
  }
  return undefined
}

/**
 * Anchor 타입 추출
 */
function extractAnchorType(name: string, level2: string | null): AnchorType | undefined {
  const lower = name.toLowerCase()
  
  if (lower.includes("load-out") || lower.includes("loadout") || 
      (level2 && level2.toLowerCase().includes("loadout"))) {
    return "LOADOUT"
  }
  if (lower.includes("sail") || lower.includes("lct") || 
      (level2 && level2.toLowerCase().includes("transport"))) {
    return "SAIL_AWAY"
  }
  if (lower.includes("berth") || lower.includes("arrival")) {
    return "BERTHING"
  }
  if (lower.includes("load-in") || lower.includes("loadin")) {
    return "LOADIN"
  }
  if (lower.includes("turning")) {
    return "TURNING"
  }
  if (lower.includes("jack") || lower.includes("jd")) {
    return "JACKDOWN"
  }
  
  return undefined
}

/**
 * 자원 태그 추출
 */
function extractResourceTags(name: string): string[] {
  const tags: string[] = []
  const lower = name.toLowerCase()
  
  if (lower.includes("crane")) {
    tags.push("CRANE")
  }
  if (lower.includes("forklift")) {
    if (lower.includes("5t") || lower.includes("5 t") || lower.includes("5-ton")) {
      tags.push("FORKLIFT_5T")
    }
    if (lower.includes("10t") || lower.includes("10 t") || lower.includes("10-ton")) {
      tags.push("FORKLIFT_10T")
    }
    if (!tags.some(t => t.includes("FORKLIFT"))) {
      tags.push("FORKLIFT")
    }
  }
  if (lower.includes("spmt")) {
    tags.push("SPMT")
  }
  
  return tags
}

/**
 * Voyage ID 추출 (TR Unit 기반)
 */
function extractVoyageId(trUnitId: TRUnitId): string {
  const match = trUnitId.match(/TR-(\d+)/)
  if (match) {
    return `V${match[1]}`
  }
  return ""
}

/**
 * 일괄 변환
 */
export function mapOptionCJsonToScheduleActivities(
  optionCData: { activities: any[] }
): ScheduleActivity[] {
  return optionCData.activities.map((raw, index) =>
    mapOptionCToScheduleActivity(raw, index)
  )
}
```

---

## 구현 체크리스트

| 단계 | 파일 | 상태 | 다음 작업 |
|------|------|------|----------|
| 1 | `lib/ssot/schedule.ts` | ✅ 완료 | - |
| 2 | `lib/utils/schedule-reflow.ts` | ⏳ 대기 | 위 코드 적용 |
| 3 | `lib/utils/schedule-mapper.ts` | ⏳ 대기 | 위 코드 적용 |
| 4 | 타입 체크 | ⏳ 대기 | `pnpm run typecheck` |
| 5 | 통합 테스트 | ⏳ 대기 | 샌드박스 테스트 |

---

위 코드를 적용하면 다음이 보장됩니다:
- 불변성 (깊은 복사)
- 사이클 탐지
- UTC 날짜 연산
- Lock/Constraint 처리
- 요약행 rollup
- 자원 충돌 탐지

Agent 모드로 전환하시면 파일 생성 및 수정을 진행하겠습니다.