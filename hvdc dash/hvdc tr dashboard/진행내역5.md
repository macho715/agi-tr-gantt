`schedule-reflow.ts`에 문제가 있습니다. 내용을 확인 중입니다.


[2 tools called]


# 중요: `schedule-reflow.ts` 파일 문제 발견

## 문제

`lib/utils/schedule-reflow.ts` 파일의 내용이 `schedule-mapper.ts`와 동일합니다. 재계산 엔진 로직이 누락되었습니다.

| 파일 | 예상 내용 | 실제 내용 | 상태 |
|------|----------|----------|------|
| `schedule-mapper.ts` | 매퍼 로직 | 매퍼 로직 | 정상 |
| `schedule-reflow.ts` | 재계산 엔진 | 매퍼 로직 (중복) | 오류 |

---

## 수정 안: `schedule-reflow.ts` 재구현

재계산 엔진을 포함한 올바른 구현입니다:

```typescript
/**
 * Schedule Reflow Engine (순수 함수)
 * 
 * 규칙:
 * - 불변성 보장 (깊은 복사)
 * - 순수 함수 (부작용 없음)
 * - UTC 날짜 연산
 * - 사이클 탐지
 * - Lock/Constraint 처리
 */

import type {
  ScheduleActivity,
  ScheduleDependency,
  ReflowResult,
  ReflowOptions,
  DateChange,
  ScheduleConflict,
} from "@/lib/ssot/schedule"
import {
  normalizeActivityId,
  parseUTCDate,
  addUTCDays,
  diffUTCDays,
  calculateFinishDate,
  DEFAULT_REFLOW_OPTIONS,
} from "@/lib/ssot/schedule"

/**
 * 의존성 그래프 기반 스케줄 재계산 (순수 함수)
 */
export function reflowSchedule(
  activities: ScheduleActivity[],
  changedActivityId: string,
  newStartDate: string,
  options: ReflowOptions = DEFAULT_REFLOW_OPTIONS
): ReflowResult {
  const opts = { ...DEFAULT_REFLOW_OPTIONS, ...options }
  
  // 1. 깊은 복사 (불변성 보장)
  const reflowed = deepCopyActivities(activities)
  
  // 2. LEAF 활동만 필터링 (SUMMARY 제외)
  const leafActivities = reflowed.filter(a => a.activity_id !== null)
  const leafIds = new Set(leafActivities.map(a => normalizeActivityId(a)))
  
  // 3. 의존성 그래프 빌드 (LEAF만)
  const graph = buildDependencyGraph(leafActivities)
  
  // 4. 사이클 탐지
  if (opts.detectCycles !== false) {
    const cycles = detectDependencyCycles(graph, leafIds)
    if (cycles.length > 0) {
      return {
        activities: reflowed,
        impact_report: {
          affected_count: 0,
          affected_ids: [],
          changes: [],
          conflicts: cycles.map(cycle => ({
            type: "DEPENDENCY_CYCLE",
            activity_id: cycle[0],
            message: `Circular dependency detected: ${cycle.join(" → ")}`,
            severity: "error",
            related_activity_ids: cycle,
          })),
        },
      }
    }
  }
  
  // 5. 변경된 활동 검증
  const normalizedId = findNormalizedId(changedActivityId, leafIds, leafActivities)
  if (!normalizedId) {
    throw new Error(`Activity ${changedActivityId} not found or is SUMMARY`)
  }
  
  const changed = leafActivities.find(a => normalizeActivityId(a) === normalizedId)
  if (!changed) {
    throw new Error(`Activity ${normalizedId} not found`)
  }
  
  // 6. Lock 검증
  if (opts.respectLocks && changed.is_locked) {
    return {
      activities: reflowed,
      impact_report: {
        affected_count: 0,
        affected_ids: [],
        changes: [],
        conflicts: [{
          type: "LOCK_VIOLATION",
          activity_id: normalizedId,
          message: `Activity ${normalizedId} is locked and cannot be changed`,
          severity: "error",
        }],
      },
    }
  }
  
  // 7. 재계산 실행
  const changes: DateChange[] = []
  const conflicts: ScheduleConflict[] = []
  
  // 변경된 활동 업데이트
  const oldStart = changed.planned_start
  const oldFinish = changed.planned_finish
  const newFinish = calculateFinishDate(newStartDate, changed.duration)
  
  updateActivityDate(reflowed, normalizedId, newStartDate, newFinish)
  
  changes.push({
    activity_id: normalizedId,
    old_start: oldStart,
    new_start: newStartDate,
    old_finish: oldFinish,
    new_finish: newFinish,
    delta_days: diffUTCDays(oldStart, newStartDate),
  })
  
  // 8. 후속 활동 재계산 (토폴로지 순서)
  const affectedIds = getAffectedActivities(graph, normalizedId, leafIds)
  const sortedAffected = topologicalSort(graph, affectedIds, leafIds)
  
  for (const activityId of sortedAffected) {
    if (activityId === normalizedId) continue
    
    const activity = leafActivities.find(a => normalizeActivityId(a) === activityId)
    if (!activity) continue
    
    // Lock 검사
    if (opts.respectLocks && activity.is_locked) {
      conflicts.push({
        type: "LOCK_VIOLATION",
        activity_id: activityId,
        message: `Activity ${activityId} is locked, cannot reschedule`,
        severity: "warn",
      })
      continue
    }
    
    // preserveOffset 모드
    if (opts.preserveOffset) {
      const offset = diffUTCDays(activity.planned_start, oldStart)
      const newStart = addUTCDays(parseUTCDate(newStartDate), offset)
        .toISOString().split("T")[0]
      const newFinish = calculateFinishDate(newStart, activity.duration)
      
      const oldStartVal = activity.planned_start
      const oldFinishVal = activity.planned_finish
      
      updateActivityDate(reflowed, activityId, newStart, newFinish)
      
      changes.push({
        activity_id: activityId,
        old_start: oldStartVal,
        new_start: newStart,
        old_finish: oldFinishVal,
        new_finish: newFinish,
        delta_days: diffUTCDays(oldStartVal, newStart),
      })
    } else {
      // 의존성 기반 계산
      const newDates = calculateDependentDates(
        activity,
        leafActivities.map(a => {
          const normalized = normalizeActivityId(a)
          const updated = reflowed.find(r => normalizeActivityId(r) === normalized)
          return updated || a
        }),
        graph
      )
      
      // Constraint 검증
      if (opts.respectConstraints && activity.constraint) {
        const constraintCheck = validateConstraint(activity, newDates)
        if (!constraintCheck.valid) {
          conflicts.push({
            type: "CONSTRAINT",
            activity_id: activityId,
            message: constraintCheck.message || "Constraint violation",
            severity: "error",
          })
          continue
        }
      }
      
      // 업데이트
      const activityIndex = reflowed.findIndex(a => normalizeActivityId(a) === activityId)
      const oldStartVal = reflowed[activityIndex].planned_start
      const oldFinishVal = reflowed[activityIndex].planned_finish
      
      reflowed[activityIndex] = {
        ...reflowed[activityIndex],
        planned_start: newDates.start,
        planned_finish: newDates.finish,
      }
      
      changes.push({
        activity_id: activityId,
        old_start: oldStartVal,
        new_start: newDates.start,
        old_finish: oldFinishVal,
        new_finish: newDates.finish,
        delta_days: diffUTCDays(oldStartVal, newDates.start),
      })
    }
  }
  
  // 9. SUMMARY 활동 rollup (자식의 min/max)
  rollupSummaryActivities(reflowed)
  
  // 10. 자원 충돌 검사
  if (opts.checkResourceConflicts) {
    const resourceConflicts = detectResourceConflicts(
      reflowed.filter(a => leafIds.has(normalizeActivityId(a)))
    )
    conflicts.push(...resourceConflicts)
  }
  
  return {
    activities: reflowed,
    impact_report: {
      affected_count: changes.length,
      affected_ids: changes.map(c => c.activity_id),
      changes,
      conflicts,
    },
  }
}

// ============================================================================
// 내부 유틸 함수
// ============================================================================

function deepCopyActivities(activities: ScheduleActivity[]): ScheduleActivity[] {
  return activities.map(a => ({
    ...a,
    depends_on: a.depends_on ? a.depends_on.map(d => ({ ...d })) : undefined,
    constraint: a.constraint ? { ...a.constraint } : undefined,
    calendar: a.calendar ? { ...a.calendar } : undefined,
    resource_tags: a.resource_tags ? [...a.resource_tags] : undefined,
  }))
}

function buildDependencyGraph(
  activities: ScheduleActivity[]
): Map<string, ScheduleDependency[]> {
  const graph = new Map<string, ScheduleDependency[]>()
  
  for (const activity of activities) {
    const id = normalizeActivityId(activity)
    graph.set(id, activity.depends_on || [])
  }
  
  return graph
}

function detectDependencyCycles(
  graph: Map<string, ScheduleDependency[]>,
  validIds: Set<string>
): string[][] {
  const cycles: string[][] = []
  const visited = new Set<string>()
  const recursionStack = new Set<string>()
  const path: string[] = []
  
  function visit(node: string) {
    if (recursionStack.has(node)) {
      const cycleStart = path.indexOf(node)
      cycles.push([...path.slice(cycleStart), node])
      return
    }
    
    if (visited.has(node)) return
    
    visited.add(node)
    recursionStack.add(node)
    path.push(node)
    
    const deps = graph.get(node) || []
    for (const dep of deps) {
      if (validIds.has(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
    
    recursionStack.delete(node)
    path.pop()
  }
  
  for (const node of validIds) {
    if (!visited.has(node)) {
      visit(node)
    }
  }
  
  return cycles
}

function getAffectedActivities(
  graph: Map<string, ScheduleDependency[]>,
  changedId: string,
  validIds: Set<string>
): Set<string> {
  const affected = new Set<string>()
  const queue = [changedId]
  
  while (queue.length > 0) {
    const current = queue.shift()!
    if (!affected.has(current)) {
      affected.add(current)
      
      for (const [activityId, deps] of graph.entries()) {
        if (deps.some(d => d.predecessorId === current) && validIds.has(activityId)) {
          if (!affected.has(activityId)) {
            queue.push(activityId)
          }
        }
      }
    }
  }
  
  return affected
}

function topologicalSort(
  graph: Map<string, ScheduleDependency[]>,
  activityIds: Set<string>,
  validIds: Set<string>
): string[] {
  const sorted: string[] = []
  const visited = new Set<string>()
  
  function visit(id: string) {
    if (visited.has(id) || !activityIds.has(id)) return
    visited.add(id)
    
    const deps = graph.get(id) || []
    for (const dep of deps) {
      if (validIds.has(dep.predecessorId) && activityIds.has(dep.predecessorId)) {
        visit(dep.predecessorId)
      }
    }
    
    sorted.push(id)
  }
  
  for (const id of activityIds) {
    visit(id)
  }
  
  return sorted
}

function calculateDependentDates(
  activity: ScheduleActivity,
  allActivities: ScheduleActivity[],
  graph: Map<string, ScheduleDependency[]>
): { start: string; finish: string } {
  const id = normalizeActivityId(activity)
  const deps = graph.get(id) || []
  
  let earliestStart = parseUTCDate(activity.planned_start)
  
  for (const dep of deps) {
    const predecessor = allActivities.find(a => normalizeActivityId(a) === dep.predecessorId)
    if (!predecessor) continue
    
    let depDate: Date
    
    switch (dep.type) {
      case "FS":
        depDate = addUTCDays(parseUTCDate(predecessor.planned_finish), dep.lagDays)
        break
      case "SS":
        depDate = addUTCDays(parseUTCDate(predecessor.planned_start), dep.lagDays)
        break
      case "FF":
        depDate = addUTCDays(
          parseUTCDate(predecessor.planned_finish),
          dep.lagDays - Math.ceil(activity.duration)
        )
        break
      case "SF":
        depDate = addUTCDays(
          parseUTCDate(predecessor.planned_start),
          dep.lagDays - Math.ceil(activity.duration)
        )
        break
      default:
        depDate = earliestStart
    }
    
    if (depDate.getTime() > earliestStart.getTime()) {
      earliestStart = depDate
    }
  }
  
  const startStr = earliestStart.toISOString().split("T")[0]
  return {
    start: startStr,
    finish: calculateFinishDate(startStr, activity.duration),
  }
}

function validateConstraint(
  activity: ScheduleActivity,
  newDates: { start: string; finish: string }
): { valid: boolean; message?: string } {
  if (!activity.constraint) return { valid: true }
  
  const constraint = activity.constraint
  const constraintDate = parseUTCDate(constraint.date)
  const newStart = parseUTCDate(newDates.start)
  const newFinish = parseUTCDate(newDates.finish)
  
  switch (constraint.type) {
    case "START_NO_EARLIER_THAN":
      if (newStart < constraintDate) {
        return {
          valid: false,
          message: `Start date must be no earlier than ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "FINISH_NO_LATER_THAN":
      if (newFinish > constraintDate) {
        return {
          valid: false,
          message: `Finish date must be no later than ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "MUST_START_ON":
      if (newDates.start !== constraint.date) {
        return {
          valid: false,
          message: `Must start on ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
    case "MUST_FINISH_ON":
      if (newDates.finish !== constraint.date) {
        return {
          valid: false,
          message: `Must finish on ${constraint.date}${constraint.reason ? ` (${constraint.reason})` : ""}`,
        }
      }
      break
  }
  
  return { valid: true }
}

function detectResourceConflicts(activities: ScheduleActivity[]): ScheduleConflict[] {
  const conflicts: ScheduleConflict[] = []
  const resourceMap = new Map<string, Array<{ id: string; start: string; finish: string }>>()
  
  for (const activity of activities) {
    if (!activity.resource_tags) continue
    const id = normalizeActivityId(activity)
    
    for (const resource of activity.resource_tags) {
      if (!resourceMap.has(resource)) {
        resourceMap.set(resource, [])
      }
      resourceMap.get(resource)!.push({
        id,
        start: activity.planned_start,
        finish: activity.planned_finish,
      })
    }
  }
  
  for (const [resource, acts] of resourceMap.entries()) {
    for (let i = 0; i < acts.length; i++) {
      for (let j = i + 1; j < acts.length; j++) {
        const a1 = acts[i]
        const a2 = acts[j]
        
        if (datesOverlap(a1.start, a1.finish, a2.start, a2.finish)) {
          conflicts.push({
            type: "RESOURCE",
            activity_id: a1.id,
            message: `Resource conflict: ${resource} is required by both ${a1.id} and ${a2.id}`,
            severity: "warn",
            related_activity_ids: [a1.id, a2.id],
          })
        }
      }
    }
  }
  
  return conflicts
}

function datesOverlap(start1: string, finish1: string, start2: string, finish2: string): boolean {
  const s1 = parseUTCDate(start1)
  const f1 = parseUTCDate(finish1)
  const s2 = parseUTCDate(start2)
  const f2 = parseUTCDate(finish2)
  return s1 <= f2 && s2 <= f1
}

function updateActivityDate(
  activities: ScheduleActivity[],
  activityId: string,
  newStart: string,
  newFinish: string
): void {
  const index = activities.findIndex(a => normalizeActivityId(a) === activityId)
  if (index >= 0) {
    activities[index] = {
      ...activities[index],
      planned_start: newStart,
      planned_finish: newFinish,
    }
  }
}

function rollupSummaryActivities(activities: ScheduleActivity[]): void {
  const summaries = activities.filter(a => a.activity_id === null)
  
  for (const summary of summaries) {
    const children = activities.filter(a =>
      a.activity_id !== null &&
      a.level1 === summary.level1 &&
      (summary.level2 === null || a.level2 === summary.level2)
    )
    
    if (children.length > 0) {
      const starts = children.map(c => parseUTCDate(c.planned_start))
      const finishes = children.map(c => parseUTCDate(c.planned_finish))
      
      const minStart = new Date(Math.min(...starts.map(d => d.getTime())))
      const maxFinish = new Date(Math.max(...finishes.map(d => d.getTime())))
      
      summary.planned_start = minStart.toISOString().split("T")[0]
      summary.planned_finish = maxFinish.toISOString().split("T")[0]
    }
  }
}

function findNormalizedId(
  id: string,
  validIds: Set<string>,
  activities: ScheduleActivity[]
): string | null {
  if (validIds.has(id)) return id
  
  for (const activity of activities) {
    const normalized = normalizeActivityId(activity)
    if (normalized === id) return normalized
  }
  
  return null
}
```

---

## 요약

| 문제 | 조치 |
|------|------|
| `schedule-reflow.ts`에 매퍼 코드가 중복 | 재계산 엔진 로직으로 교체 필요 |
| 재계산 엔진 누락 | 위 코드로 구현 필요 |

---

## 수정 후 확인 사항

1. 타입 체크: `pnpm run typecheck`
2. 중복 제거: `schedule-mapper.ts`와 내용 분리 확인
3. 기능 확인: `reflowSchedule` 함수 export 확인

---

`schedule-reflow.ts`를 위 코드로 교체하면 됩니다. Agent 모드로 전환하시면 수정을 적용하겠습니다.